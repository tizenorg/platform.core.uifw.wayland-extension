<protocol name="tizen_extension">
  <interface name="tizen_surface" version="1">
    <request name="get_tizen_resource">
      <arg name="id" type="new_id" interface="tizen_resource" />
      <arg name="surface" type="object" interface="wl_surface" />
    </request>
  </interface>

  <interface name="tizen_resource" version="1">
    <request name="destroy" type="destructor" />

    <event name="resource_id">
      <arg name="id" type="uint" />
    </event>
  </interface>

  <interface name="tizen_policy" version="1">
    <request name="get_visibility">
      <arg name="id" type="new_id" interface="tizen_visibility" summary="new visibility object"/>
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>

    <request name="get_position">
      <arg name="id" type="new_id" interface="tizen_position" summary="new position object"/>
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>

    <request name="activate">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>

    <request name="activate_below_by_res_id">
      <arg name="res_id" type="uint" />
      <arg name="below_res_id" type="uint" />
    </request>

    <request name="raise">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>

    <request name="lower">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>

    <request name="lower_by_res_id">
      <arg name="res_id" type="uint" />
    </request>

    <request name="set_focus_skip">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>

    <request name="unset_focus_skip">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>

    <request name="set_role">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
      <arg name="role" type="string"/>
    </request>

    <enum name="win_type">
      <entry name="none" value="0"/>
      <entry name="toplevel" value="1"/>
      <entry name="fullscreen" value="2"/>
      <entry name="maximized" value="3"/>
      <entry name="transient" value="4"/>
      <entry name="menu" value="5"/>
      <entry name="dnd" value="6"/>
      <entry name="custom" value="7"/>
      <entry name="notification" value="8"/>
    </enum>

    <request name="set_type">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="win_type" type="uint" />
    </request>

    <!-- for conformant -->
    <request name="set_conformant">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>

    <request name="unset_conformant">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>

    <request name="get_conformant">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>

    <event name="conformant">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
      <arg name="is_conformant" type="uint"/>
    </event>

    <enum name="conformant_part">
      <entry name="indicator" value="0"/>
      <entry name="keyboard" value="1"/>
      <entry name="clipboard" value="2"/>
    </enum>

    <event name="conformant_area">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
      <arg name="conformant_part" type="uint"/>
      <arg name="state" type="uint"/>
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
      <arg name="w" type="int"/>
      <arg name="h" type="int"/>
    </event>

    <enum name="error_state">
      <entry name="none" value="0"/>
      <entry name="permission_denied" value="1"/>
    </enum>

    <!-- for notification -->
    <enum name="level">
      <entry name="1" value="0"/>
      <entry name="2" value="1"/>
      <entry name="3" value="2"/>
      <entry name="none" value="-1"/>
      <entry name="default" value="10"/>
      <entry name="medium" value="20"/>
      <entry name="high" value="30"/>
      <entry name="top" value="40"/>
    </enum>

    <request name="set_notification_level">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="level" type="int"/>
    </request>

    <event name="notification_done">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="level" type="int"/>
      <arg name="error_state" type="uint"/>
    </event>

    <!-- for transient_for -->
    <request name="set_transient_for">
      <arg name="child_id" type="uint" />
      <arg name="parent_id" type="uint" />
    </request>

    <request name="unset_transient_for">
      <arg name="child_id" type="uint" />
    </request>

    <event name="transient_for_done">
      <arg name="child_id" type="uint"/>
    </event>

    <!-- for window_screen_mode -->
    <enum name="mode">
      <entry name="default" value="0"/>
      <entry name="always_on" value="1"/>
    </enum>

    <request name="set_window_screen_mode">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="mode" type="uint"/>
    </request>

    <event name="window_screen_mode_done">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="mode" type="uint"/>
      <arg name="error_state" type="uint"/>
    </event>

    <!-- for subsurface -->
    <request name="place_subsurface_below_parent">
      <arg name="subsurface" type="object" interface="wl_subsurface"/>
    </request>

    <request name="get_subsurface">
      <arg name="id" type="new_id" interface="wl_subsurface" />
      <arg name="surface" type="object" interface="wl_surface" />
      <arg name="parent_id" type="uint" />
    </request>

    <!-- for opaque_state -->
    <request name="set_opaque_state">
      <arg name="surface" type="object" interface="wl_surface" />
      <arg name="state" type="int"/>
    </request>

    <!-- for iconify -->
    <request name="iconify">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>
    <request name="uniconify">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>

    <event name="iconify_state_changed">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="iconified" type="uint"/>
      <arg name="force" type="uint"/>
    </event>

    <!-- for aux_hint -->
    <request name="add_aux_hint">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="id" type="int" />
      <arg name="name" type="string" />
      <arg name="value" type="string" />
    </request>

    <request name="change_aux_hint">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="id" type="int" />
      <arg name="value" type="string" />
    </request>

    <request name="del_aux_hint">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="id" type="int" />
    </request>

    <request name="get_supported_aux_hints">
      <arg name="surface" type="object" interface="wl_surface"/>
    </request>

    <event name="supported_aux_hints">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="hints" type="array" />
      <arg name="num_hints" type="uint"/>
    </event>

    <event name="allowed_aux_hint">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="id" type="int" />
    </event>

    <!-- for background state -->
    <request name="set_background_state">
       <arg name="pid" type="uint" />
    </request>

    <request name="unset_background_state">
       <arg name="pid" type="uint" />
    </request>

    <!-- for floating mode -->
    <request name="set_floating_mode">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>

    <request name="unset_floating_mode">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>

    <!-- for stack mode -->
    <enum name="stack_mode">
      <entry name="none" value="0"/>
      <entry name="above" value="1"/>
      <entry name="below" value="2"/>
    </enum>

    <request name="set_stack_mode">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="mode" type="uint" />
    </request>
  </interface>

  <interface name="tizen_visibility" version="1">
    <request name="destroy" type="destructor"/>

    <enum name="visibility">
      <entry name="unobscured" value="0"/>
      <entry name="partially_obscured" value="1"/>
      <entry name="fully_obscured" value="2"/>
    </enum>

    <event name="notify">
      <arg name="visibility" type="uint"/>
    </event>
  </interface>

  <interface name="tizen_position" version="1">
    <request name="destroy" type="destructor"/>

    <request name="set">
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
    </request>

    <event name="changed">
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
    </event>
  </interface>

  <interface name="tizen_gesture" version="1">
    <enum name="error">
      <entry name="none" value="0"/>
      <entry name="invalid_data" value="1"/>
      <entry name="no_permission" value="2"/>
      <entry name="no_system_resources" value="3"/>
      <entry name="grabbed_already" value="4"/>
    </enum>

    <enum name="type">
      <entry name="swipe" value="1"/>
    </enum>

    <enum name="mode">
      <entry name="begin" value="1"/>
      <entry name="update" value="2"/>
      <entry name="end" value="3"/>
      <entry name="done" value="4"/>
    </enum>

    <enum name="direction">
      <entry name="down" value="1"/>
      <entry name="left" value="2"/>
      <entry name="up" value="4"/>
      <entry name="right" value="8"/>
    </enum>

    <request name="grab_swipe">
      <arg name="num_of_fingers" type="uint"/>
      <arg name="direction" type="uint"/>
    </request>

    <request name="ungrab_swipe">
      <arg name="num_of_fingers" type="uint"/>
      <arg name="direction" type="uint"/>
    </request>

    <event name="grab_swipe_notify">
      <arg name="num_of_fingers" type="uint"/>
      <arg name="direction" type="uint" enum="direction"/>
      <arg name="error" type="uint"/>
    </event>

    <event name="swipe">
      <arg name="mode" type="uint" enum="mode"/>
      <arg name="num_of_fingers" type="uint"/>
      <arg name="sx" type="int" summary="x coordinate of touch down point"/>
      <arg name="sy" type="int" summary="y coordinate of touch down point"/>
      <arg name="direction" type="uint" enum="direction"/>
    </event>
  </interface>

  <interface name="tizen_keyrouter" version="1">
    <description summary="an interface to set each focus for each key">
      In tradition, all the keys in a keyboard and a device on which
      some keys are attached will be sent to focus surface by default.
      Currently it's possible to set up each focus for each key in a keyboard and a device.
      Therefore, by setting a key grab for a surface, the owner of the
      surface will get the key event when it has the key grab for the key.
    </description>

    <enum name="error">
      <entry name="none" value="0" summary="no error"/>
      <entry name="invalid_surface" value="1" summary="Given surface is invalid."/>
      <entry name="invalid_key" value="2" summary="Given key is invalid."/>
      <entry name="invalid_mode" value="3" summary="Given mode is invalid."/>
      <entry name="grabbed_already" value="4" summary="The key has been grabbed already."/>
      <entry name="no_permission" value="5" summary="The wl client has no permission to grab the key."/>
      <entry name="no_system_resources" value="6" summary="System resources are insufficient."/>
      <entry name="invalid_array" value="7" summary="Given array has invalid pairs or data type."/>
    </enum>

    <enum name="mode">
      <description summary="mode for a key grab">
        This value is used to set a mode for a key grab. With this mode and
        the order of the surface between surfaces' stack, the compositor will determine the destination client
        surface.
      </description>
      <entry name="none" value="0" summary="none"/>
      <entry name="shared" value="1"
       summary="mode to get a key grab with the other client surfaces when the focused client surface gets the key"/>
      <entry name="topmost" value="2"
       summary="mode to get a key grab when the client surface is the top most surface"/>
      <entry name="overridable_exclusive" value="3"
       summary="mode to get a key grab exclusively, overridably regardless of the order in the surface stack"/>
      <entry name="exclusive" value="4"
       summary="mode to get a key grab exclusively regardless of the order in surface stack"/>
      <entry name="registered" value="5"
       summary="mode to get a key grab only when a requesting surface is on top among the registering surfaces for the key"/>
      <entry name="displayoff" value="6"
       summary="mode to get a key grab only when a displayoff mode is enabled"/>
      <entry name="pictureoff" value="6"
       summary="temporary maintain this enum to maintain compatibility."/>
    </enum>

    <request name="set_keygrab">
      <arg name="surface" type="object" interface="wl_surface" allow-null="true"/>
      <arg name="key" type="uint"/>
      <arg name="mode" type="uint"/>
    </request>

    <request name="unset_keygrab">
      <arg name="surface" type="object" interface="wl_surface" allow-null="true"/>
      <arg name="key" type="uint"/>
    </request>

    <request name="get_keygrab_status">
      <arg name="surface" type="object" interface="wl_surface" allow-null="true"/>
      <arg name="key" type="uint"/>
    </request>

    <request name="set_keygrab_list">
      <arg name="surface" type="object" interface="wl_surface" allow-null="true"/>
      <arg name="grab_list" type="array" summary="array of two integer variables pairs each pairs consist of keycode and keygrab mode"/>
    </request>

    <request name="unset_keygrab_list">
      <arg name="surface" type="object" interface="wl_surface" allow-null="true"/>
      <arg name="ungrab_list" type="array" summary="array of integer variables meaning keycode wanted to ungrab"/>
    </request>

    <event name="keygrab_notify">
      <arg name="surface" type="object" interface="wl_surface" allow-null="true"/>
      <arg name="key" type="uint"/>
      <arg name="mode" type="uint"/>
      <arg name="error" type="uint"/>
    </event>

    <event name="keygrab_notify_list">
      <arg name="surface" type="object" interface="wl_surface" allow-null="true"/>
      <arg name="grab_result" type="array" summary="array of three integer variables pairs each pairs consist of keycode, keygrab mode and keygrab result"/>
    </event>

    <enum name="register_mode">
      <entry name="none_register" value="1"/>
      <entry name="pass_register" value="2"/>
      <entry name="grab_register" value="3"/>
    </enum>

    <request name="register_mode_config">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="mode" type="uint"/>
      <arg name="enable" type="uint"/>
    </request>

    <event name="register_mode_config_notify">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="mode" type="uint"/>
      <arg name="enable" type="uint"/>
      <arg name="error" type="uint"/>
    </event>

    <request name="key_monitor">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="enable" type="uint"/>
    </request>

    <event name="key_monitor_notify">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="enable" type="uint"/>
      <arg name="error" type="uint"/>
    </event>

    <request name="get_register_delivery">
      <arg name="key" type="uint"/>
    </request>

    <event name="get_register_delivery_notify">
      <arg name="key" type="uint"/>
      <arg name="result" type="uint"/>
    </event>
  </interface>

  <interface name="tizen_screenshooter" version="1">
    <description summary="interface for tizen-screenshooter">
      Clients can get a screenmirror object from this interface.
    </description>

    <request name="get_screenmirror">
      <description summary="create a screenmirror object">
        Before using screenmirror, a client should get a screenmirror object from display
        server.
      </description>
      <arg name="id" type="new_id" interface="tizen_screenmirror" summary="new screenmirror object"/>
      <arg name="output" type="object" interface="wl_output" summary="output object for screenmirror"/>
    </request>

    <event name="format">
      <description summary="supported format for screenshooter">
        The tbm format codes match the #defines in tbm_surface.h. The formats actually
        supported by the compositor will be reported by the format event.
      </description>
      <arg name="format" type="uint"/>
    </event>

  </interface>

  <interface name="tizen_screenmirror" version="1">
    <description summary="interface for screenmirror">
      A client can use this interface to get stream images of screen. Before starting,
      queue all buffers. Then, start a screenmirror. After starting, a dequeued event
      will occur when drawing a captured image on a buffer is finished. You might
      need to queue the dequeued buffer again to get a new image from display server.
    </description>

    <request name="destroy" type="destructor"/>

    <request name="set_stretch">
      <arg name="stretch" type="uint" summary="stretch type for screenmirror"/>
    </request>

    <request name="queue">
      <description summary="queue a buffer"/>
        <arg name="buffer" type="object" interface="wl_buffer" summary="buffer object for screenmirror"/>
    </request>

    <request name="dequeue">
      <description summary="dequeue a buffer">
        A user can dequeue a buffer from display server when he wants to take back it from server.
      </description>
      <arg name="buffer" type="object" interface="wl_buffer" summary="buffer object for screenmirror"/>
    </request>

    <request name="start"/>
    <request name="stop"/>

    <enum name="content">
      <entry name="normal" value="0"/>
      <entry name="video" value="1"/>
    </enum>

    <enum name="stretch">
      <entry name="keep_ratio" value="0"/>
      <entry name="fully" value="1"/>
    </enum>

    <event name="dequeued">
      <description summary="dequeued event">
        occurs when drawing a captured image on a buffer is finished
      </description>
      <arg name="buffer" type="object" interface="wl_buffer" summary="dequeued buffer which contains a captured image"/>
    </event>

    <event name="content">
      <description summary="content changed event">
        occurs when the content of a captured image is changed. (normal or video)
      </description>
      <arg name="content" type="uint"/>
    </event>

    <event name="stop">
      <description summary="stop event">
        occurs when the screenmirror is stopped eventually
      </description>
    </event>
  </interface>

  <interface name="tizen_video" version="1">

    <description summary="interface for tizen-video">
      Clients can get the video information that the compositor can handle from this interface.
    </description>

    <enum name="error">
      <entry name="none" value="0"/>
      <entry name="object_exists" value="1"/>
    </enum>

    <event name="format">
      <description summary="supported format for video">
        The tbm format codes match the #defines in tbm_surface.h. The formats actually
        supported by the compositor will be reported by the format event.
      </description>
      <arg name="format" type="uint"/>
    </event>

    <request name="get_object">
      <arg name="id" type="new_id" interface="tizen_video_object" />
      <arg name="surface" type="object" interface="wl_surface" />
    </request>

  </interface>

  <interface name="tizen_video_object" version="1">

    <event name="attribute">
      <arg name="name" type="string"/>
      <arg name="value" type="uint"/>
    </event>

    <event name="size">
      <arg name="min_w" type="int"/>
      <arg name="min_h" type="int"/>
      <arg name="max_w" type="int"/>
      <arg name="max_h" type="int"/>
      <arg name="prefer_align" type="int"/>
    </event>

    <request name="destroy" type="destructor"/>
    <request name="set_attribute">
      <arg name="name" type="string"/>
      <arg name="value" type="int"/>
    </request>

  </interface>

  <interface name="tizen_embedded_compositor" version="1">

    <description summary="global embedded compositor object">
      The global obejct. Wayland has 3 type of compositor, embedded compositor is one of them.
      But tizen application is sendboxing by smack, then a application not allow commutication to other application by socket.
      So system or session compositor create socket and send to embedded compostior.
    </description>

    <request name="get_socket">
      <description summary="create new socket">
        The get_socket request ask the server to create socket and emit socket event.
      </description>
    </request>

    <event name="socket">
      <description summary="socket fd">
        Sent immediately after get_socket request
      </description>
      <arg name="sock_fd" type="fd"/>
    </event>

  </interface>

  <interface name="tizen_input_device_manager" version="1">
    <description summary="global input device manager object">
      Tizen input device manager is a global interface. This object has device add/remove events
      to provide tizen input device object to a client. This allows for a client to get the con

      Be sure to bind this interface after binding wl_seat interface.
      Tizen input device manager interface will only provide device add/remove event for devices
      which belongs to the wl_seat object(s) bound by the client. Therefore, the compositor needs to
      create/send the device add/remove event only for the current client's seat(s).
    </description>

    <event name="device_add">
      <description summary="device addition event">
        The device add/remove notification is going to be sent when a physical/logical device is
        added/removed to/from the given seat. Note that a tizen input device object can be assigned to
        a wl_seat and can also be assigned to the other wl_seat at any time. Whenever a relationship between
        a tizen input device object changes, device remove event from the current wl_seat object will be made
        and device add event to the other wl_seat object will also be mode.
      </description>
      <arg name="serial" type="uint"/>
      <arg name="identifier" type="string"/>
      <arg name="device" type="new_id" interface="tizen_input_device"/>
      <arg name="seat" type="object" interface="wl_seat"/>
    </event>

    <event name="device_remove">
      <description summary="device removal event">
        The device add/remove notification is going to be sent when a physical/logical device is
        added/removed to/from the given seat. Note that a tizen input device object can be assigned to
        a wl_seat and can also be assigned to the other wl_seat at any time. Whenever a relationship between
        a tizen input device object changes, device remove event from the current wl_seat object will be made
        and device add event to the other wl_seat object will also be mode.
      </description>
      <arg name="serial" type="uint"/>
      <arg name="identifier" type="string"/>
      <arg name="device" type="object" interface="tizen_input_device"/>
      <arg name="seat" type="object" interface="wl_seat"/>
    </event>

    <enum name="clas">
       <description summary="device class">
       </description>
       <entry name="none" value="0" summary="none of class"/>
       <entry name="mouse" value="1" summary="mouse class"/>
       <entry name="keyboard" value="2" summary="keyboard class"/>
       <entry name="touchscreen" value="4" summary="touchscreen class"/>
    </enum>

    <enum name="error">
      <entry name="none" value="0" summary="no error"/>
      <entry name="no_permission" value="1" summary="no permission"/>
      <entry name="invalid_class" value="2" summary="invalid class"/>
      <entry name="blocked_already" value="3" summary="blocked already by the other client"/>
      <entry name="no_system_resources" value="4" summary="no system resources such as memory lack"/>
      <entry name="invalid_parameter" value="5" summary="argument is invalid"/>
      <entry name="invalid_surface" value="6" summary="the given surface is not visible or pointer is not on the given surface"/>
      <entry name="no_pointer_available" value="7" summary="there is no pointer available to warp"/>
    </enum>

    <event name="error">
      <description summary="error event">
      </description>
      <arg name="errorcode" type="uint" enum="error"/>
    </event>

    <event name="block_expired">
      <description summary="block expiration event">
        This event will be sent if the duration of existing block is expired.
        Note that no block expired event will be sent if there is no block for the client.
      </description>
    </event>

    <request name="block_events">
      <description summary="request to block sending event(s)">
        This request allows a client to request to block one or more events for its purpose.
        By specifying class as an argument in the request, the events belongs to the class will be blocked
        during the given duration. Note that an error event will be sent if there is any error.
      </description>
      <arg name="serial" type="uint" summary=""/>
      <arg name="clas" type="uint" enum="clas"/>
      <arg name="duration" type="uint" summary="time duration with millisecond granularity"/>
    </request>

    <request name="unblock_events">
      <description summary="request to unblock sending event(s)">
        This request allows a client to request to release the existing block for the client.
        Note that no error event will be sent if there is no existing block for the client.
      </description>
      <arg name="serial" type="uint" summary=""/>
    </request>

    <request name="init_generator">
      <description summary="initialize input generator system">
      </description>
    </request>

    <request name="deinit_generator">
      <description summary="deinitialize input generator system">
      </description>
    </request>

    <request name="generate_key">
      <description summary="generate a key event using specific or default device">
      </description>
      <arg name="keyname" type="string"/>
      <arg name="pressed" type="uint"/>
    </request>

    <enum name="pointer_event_type">
      <entry name="begin" value="0"/>
      <entry name="update" value="1"/>
      <entry name="end" value="2"/>
    </enum>

    <request name="generate_pointer">
      <description summary="generate a pointer event using specific or default device">
      </description>
      <arg name="type" type="uint" enum="pointer_event_type"/>
      <arg name="x" type="uint"/>
      <arg name="y" type="uint"/>
      <arg name="button" type="uint"/>
    </request>

    <request name="generate_touch">
      <description summary="generate a touch event using specific or default device">
      </description>
      <arg name="type" type="uint" enum="pointer_event_type"/>
      <arg name="x" type="uint"/>
      <arg name="y" type="uint"/>
      <arg name="finger" type="uint"/>
    </request>

    <request name="pointer_warp">
      <description summary="warp pointer to the relative position to the given surface">
      </description>
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="x" type="fixed"/>
      <arg name="y" type="fixed"/>
    </request>
  </interface>

  <interface name="tizen_input_device" version="1">
    <description summary="tizen input device object">
      The tizen_input_device interface represents one or more input devices associated with a physical/logical
      input device. This interface provides device specific information/events to allows for client to identify
      the source device of an event or to get the additional axes/attributes of a device.
      Note that a tizen_input_device object can be used for a physical input device and can also be used for a
      group of input devices. e.g. a group of mouse devices
    </description>

    <enum name="clas">
       <description summary="device class">
       </description>
       <entry name="none" value="0" summary="none of class"/>
       <entry name="mouse" value="1" summary="mouse class"/>
       <entry name="keyboard" value="2" summary="keyboard class"/>
       <entry name="touchscreen" value="4" summary="touchscreen class"/>
    </enum>

    <enum name="subclas">
       <description summary="device subclass">
       </description>
       <entry name="none" value="0" summary="none of subclass"/>
    </enum>

    <enum name="axis_type">
      <description summary="axis type enums which can be supported by a device">
      </description>
      <entry name="none" value="0" summary="radius of x axis of an event area e.g. touching area with a finger or a pen"/>
      <entry name="radius_x" value="1" summary="radius of x axis of an event area e.g. touching area with a finger or a pen"/>
      <entry name="radius_y" value="2" summary="radius of y axis of an event area e.g. touching area with a finger or a pen"/>
      <entry name="pressure" value="3" summary="pressure in an event area e.g. touching area with a finger or a pen"/>
      <entry name="angle" value="4" summary="angle in an event area e.g. touching area with a finger or a pen"/>
      <entry name="detent" value="5" summary="detent value e.g. moved distance with a rotary device"/>
    </enum>

    <event name="device_info">
      <description summary="event contains device information">
      </description>
      <arg name="name" type="string"/>
      <arg name="clas" type="uint" enum="clas"/>
      <arg name="subclas" type="uint" enum="subclas"/>
      <arg name="axes" type="array" summary="array of axis enum"/>
    </event>

    <event name="event_device">
      <description summary="event indicates the source device associated with a wl_pointer/keyboard/touch event">
      </description>
      <arg name="serial" type="uint"/>
      <arg name="name" type="string"/>
      <arg name="time" type="uint" summary="timestamp with millisecond granularity"/>
    </event>

    <request name="select_axes">
      <description summary="request for selecting some of axes among the axes supported by a tizen_input_device object">
      </description>
      <arg name="axes" type="array" summary="array of axis num"/>
    </request>

    <event name="axis">
      <description summary="axis change event">
      </description>
      <arg name="axis_type" type="uint" enum="axis_type"/>
      <arg name="value" type="fixed" summary="axis value"/>
    </event>

    <request name="release" type="destructor">
      <description summary="release the tizen_input_device object">
      </description>
    </request>
  </interface>

  <interface name="tizen_launchscreen" version="1">
    <request name="create_img">
      <arg name="id" type="new_id" interface="tizen_launch_image" summary="new tizen_launch_image object"/>
    </request>
  </interface>

  <interface name="tizen_launch_image" version="1">
    <!-- launch img -->
    <enum name="file_type">
      <entry name="img" value="0" summary="splash image file path"/>
      <entry name="edj" value="1" summary="splash edj file path"/>
    </enum>

    <enum name="indicator">
      <entry name="off" value="0" summary="splash hide indicator"/>
      <entry name="on" value="1" summary="splash show indicator"/>
    </enum>

    <enum name="rotation">
      <entry name="0" value="0" summary="rotation angle 0 degree"/>
      <entry name="90" value="90" summary="rotation angle 90 degree"/>
      <entry name="180" value="180" summary="rotation angle 180 degree"/>
      <entry name="270" value="270" summary="rotation angle 270 degree"/>
    </enum>

    <request name="destroy" type="destructor"/>

    <request name="launch">
      <arg name="file" type="string"/>
      <arg name="file_type" type="uint" />
      <arg name="color_depth" type="uint" />
      <arg name="rotation" type="uint" />
      <arg name="indicator" type="uint" />
      <arg name="options" type="array" />
    </request>

    <request name="owner">
      <arg name="pid" type="uint" />
    </request>

    <request name="show">
    </request>

    <request name="hide">
    </request>
  </interface>

  <interface name="tizen_effect" version="1">
     <enum name="type">
      <entry name="none" value="0" summary="none"/>
      <entry name="show" value="1" summary="show effect of window"/>
      <entry name="hide" value="2" summary="hide effect of window"/>
      <entry name="restack" value="3" summary="restack effect of window"/>
     </enum>
     <request name="destroy" type="destructor" />
     <event name="start">
       <arg name="surface" type="object" interface="wl_surface"/>
       <arg name="type" type="uint" />
     </event>
     <event name="end">
       <arg name="surface" type="object" interface="wl_surface"/>
       <arg name="type" type="uint" />
     </event>
  </interface>

  <interface name="tizen_display_policy" version="1">
    <enum name="error_state">
      <entry name="none" value="0"/>
      <entry name="permission_denied" value="1"/>
    </enum>
    <!-- for window brightness -->
    <request name="set_window_brightness">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="brightness" type="int"/>
    </request>

    <event name="window_brightness_done">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="brightness" type="int"/>
      <arg name="error_state" type="uint"/>
    </event>
  </interface>
</protocol>
