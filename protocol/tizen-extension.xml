<protocol name="tizen_extension">

  <interface name="tizen_surface" version="1">
    <request name="get_tizen_resource">
      <arg name="id" type="new_id" interface="tizen_resource" />
      <arg name="surface" type="object" interface="wl_surface" />
    </request>
  </interface>

  <interface name="tizen_resource" version="1">
    <request name="destroy" type="destructor" />

    <event name="resource_id">
      <arg name="id" type="uint" />
    </event>
  </interface>

  <interface name="tizen_policy" version="1">
    <request name="get_visibility">
      <arg name="id" type="new_id" interface="tizen_visibility" summary="new visibility object"/>
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>

    <request name="get_position">
      <arg name="id" type="new_id" interface="tizen_position" summary="new position object"/>
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>

    <request name="activate">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>

    <request name="raise">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>

    <request name="lower">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>

    <request name="lower_by_res_id">
      <arg name="res_id" type="uint" />
    </request>

    <request name="set_focus_skip">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>

    <request name="unset_focus_skip">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>

    <request name="set_role">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
      <arg name="role" type="string"/>
    </request>

    <enum name="win_type">
      <entry name="none" value="0"/>
      <entry name="toplevel" value="1"/>
      <entry name="fullscreen" value="2"/>
      <entry name="maximized" value="3"/>
      <entry name="transient" value="4"/>
      <entry name="menu" value="5"/>
      <entry name="dnd" value="6"/>
      <entry name="custom" value="7"/>
      <entry name="notification" value="8"/>
    </enum>

    <request name="set_type">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="win_type" type="uint" />
    </request>

    <!-- for conformant -->
    <request name="set_conformant">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>

    <request name="unset_conformant">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>

    <request name="get_conformant">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>

    <event name="conformant">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
      <arg name="is_conformant" type="uint"/>
    </event>

    <enum name="conformant_part">
      <entry name="indicator" value="0"/>
      <entry name="keyboard" value="1"/>
      <entry name="clipboard" value="2"/>
    </enum>

    <event name="conformant_area">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
      <arg name="conformant_part" type="uint"/>
      <arg name="state" type="uint"/>
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
      <arg name="w" type="int"/>
      <arg name="h" type="int"/>
    </event>

    <enum name="error_state">
      <entry name="none" value="0"/>
      <entry name="permission_denied" value="1"/>
    </enum>

    <!-- for notification -->
    <enum name="level">
      <entry name="1" value="0"/>
      <entry name="2" value="1"/>
      <entry name="3" value="2"/>
      <entry name="none" value="-1"/>
      <entry name="default" value="10"/>
      <entry name="medium" value="20"/>
      <entry name="high" value="30"/>
      <entry name="top" value="40"/>
    </enum>

    <request name="set_notification_level">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="level" type="int"/>
    </request>

    <event name="notification_done">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="level" type="int"/>
      <arg name="error_state" type="uint"/>
    </event>

    <!-- for transient_for -->
    <request name="set_transient_for">
      <arg name="child_id" type="uint" />
      <arg name="parent_id" type="uint" />
    </request>

    <request name="unset_transient_for">
      <arg name="child_id" type="uint" />
    </request>

    <event name="transient_for_done">
      <arg name="child_id" type="uint"/>
    </event>

    <!-- for window_screen_mode -->
    <enum name="mode">
      <entry name="default" value="0"/>
      <entry name="always_on" value="1"/>
    </enum>

    <request name="set_window_screen_mode">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="mode" type="uint"/>
    </request>

    <event name="window_screen_mode_done">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="mode" type="uint"/>
      <arg name="error_state" type="uint"/>
    </event>

    <!-- for subsurface -->
    <request name="place_subsurface_below_parent">
      <arg name="subsurface" type="object" interface="wl_subsurface"/>
    </request>

    <!-- for opaque_state -->
    <request name="set_opaque_state">
      <arg name="surface" type="object" interface="wl_surface" />
      <arg name="state" type="int"/>
    </request>

    <!-- for iconify -->
    <request name="iconify">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>
    <request name="uniconify">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>

    <!-- for aux_hint -->
    <request name="add_aux_hint">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="id" type="int" />
      <arg name="name" type="string" />
      <arg name="value" type="string" />
    </request>

    <request name="change_aux_hint">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="id" type="int" />
      <arg name="value" type="string" />
    </request>

    <request name="del_aux_hint">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="id" type="int" />
    </request>

    <request name="get_supported_aux_hints">
      <arg name="surface" type="object" interface="wl_surface"/>
    </request>

    <event name="supported_aux_hints">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="hints" type="array" />
      <arg name="num_hints" type="uint"/>
    </event>

    <event name="allowed_aux_hint">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="id" type="int" />
    </event>

  </interface>

  <interface name="tizen_visibility" version="1">
    <request name="destroy" type="destructor"/>

    <enum name="visibility">
      <entry name="unobscured" value="0"/>
      <entry name="partially_obscured" value="1"/>
      <entry name="fully_obscured" value="2"/>
    </enum>

    <event name="notify">
      <arg name="visibility" type="uint"/>
    </event>
  </interface>

  <interface name="tizen_position" version="1">
    <request name="destroy" type="destructor"/>

    <request name="set">
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
    </request>

    <event name="changed">
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
    </event>
  </interface>

  <interface name="tizen_keyrouter" version="1">
    <description summary="an interface to set each focus for each key">
      In tradition, all the keys in a keyboard and a device on which
      some keys are attached will be sent to focus surface by default.
      Currently it's possible to set up each focus for each key in a keyboard and a device.
      Therefore, by setting a key grab for a surface, the owner of the
      surface will get the key event when it has the key grab for the key.
    </description>

    <enum name="error">
      <entry name="none" value="0" summary="no error"/>
      <entry name="invalid_surface" value="1" summary="Given surface is invalid."/>
      <entry name="invalid_key" value="2" summary="Given key is invalid."/>
      <entry name="invalid_mode" value="3" summary="Given mode is invalid."/>
      <entry name="grabbed_already" value="4" summary="The key has been grabbed already."/>
      <entry name="no_permission" value="5" summary="The wl client has no permission to grab the key."/>
      <entry name="no_system_resources" value="6" summary="System resources are insufficient."/>
      <entry name="invalid_array" value="7" summary="Given array has invalid pairs or data type."/>
    </enum>

    <enum name="mode">
      <description summary="mode for a key grab">
        This value is used to set a mode for a key grab. With this mode and
        the order of the surface between surfaces' stack, the compositor will determine the destination client
        surface.
      </description>
      <entry name="none" value="0" summary="none"/>
      <entry name="shared" value="1"
       summary="mode to get a key grab with the other client surfaces when the focused client surface gets the key"/>
      <entry name="topmost" value="2"
       summary="mode to get a key grab when the client surface is the top most surface"/>
      <entry name="overridable_exclusive" value="3"
       summary="mode to get a key grab exclusively, overridably regardless of the order in the surface stack"/>
      <entry name="exclusive" value="4"
       summary="mode to get a key grab exclusively regardless of the order in surface stack"/>
    </enum>

    <request name="set_keygrab">
      <arg name="surface" type="object" interface="wl_surface" allow-null="true"/>
      <arg name="key" type="uint"/>
      <arg name="mode" type="uint"/>
    </request>

    <request name="unset_keygrab">
      <arg name="surface" type="object" interface="wl_surface" allow-null="true"/>
      <arg name="key" type="uint"/>
    </request>

    <request name="get_keygrab_status">
      <arg name="surface" type="object" interface="wl_surface" allow-null="true"/>
      <arg name="key" type="uint"/>
    </request>

    <request name="set_keygrab_list">
      <arg name="surface" type="object" interface="wl_surface" allow-null="true"/>
      <arg name="grab_list" type="array" summary="array of two integer variables pairs each pairs consist of keycode and keygrab mode"/>
    </request>

    <request name="unset_keygrab_list">
      <arg name="surface" type="object" interface="wl_surface" allow-null="true"/>
      <arg name="ungrab_list" type="array" summary="array of integer variables meaning keycode wanted to ungrab"/>
    </request>

    <event name="keygrab_notify">
      <arg name="surface" type="object" interface="wl_surface" allow-null="true"/>
      <arg name="key" type="uint"/>
      <arg name="mode" type="uint"/>
      <arg name="error" type="uint"/>
    </event>

    <event name="keygrab_notify_list">
      <arg name="surface" type="object" interface="wl_surface" allow-null="true"/>
      <arg name="grab_result" type="array" summary="array of three integer variables pairs each pairs consist of keycode, keygrab mode and keygrab result"/>
    </event>
  </interface>

  <interface name="tizen_screenshooter" version="1">
    <description summary="interface for tizen-screenshooter">
      Clients can get a screenmirror object from this interface.
    </description>

    <request name="get_screenmirror">
      <description summary="create a screenmirror object">
        Before using screenmirror, a client should get a screenmirror object from display
        server.
      </description>
      <arg name="id" type="new_id" interface="tizen_screenmirror" summary="new screenmirror object"/>
      <arg name="output" type="object" interface="wl_output" summary="output object for screenmirror"/>
    </request>

    <event name="format">
      <description summary="supported format for screenshooter">
        The tbm format codes match the #defines in tbm_surface.h. The formats actually
        supported by the compositor will be reported by the format event.
      </description>
      <arg name="format" type="uint"/>
    </event>

  </interface>

  <interface name="tizen_screenmirror" version="1">
    <description summary="interface for screenmirror">
      A client can use this interface to get stream images of screen. Before starting,
      queue all buffers. Then, start a screenmirror. After starting, a dequeued event
      will occur when drawing a captured image on a buffer is finished. You might
      need to queue the dequeued buffer again to get a new image from display server.
    </description>

    <request name="destroy" type="destructor"/>

    <request name="set_stretch">
      <arg name="stretch" type="uint" summary="stretch type for screenmirror"/>
    </request>

    <request name="queue">
      <description summary="queue a buffer"/>
        <arg name="buffer" type="object" interface="wl_buffer" summary="buffer object for screenmirror"/>
    </request>

    <request name="dequeue">
      <description summary="dequeue a buffer">
        A user can dequeue a buffer from display server when he wants to take back it from server.
      </description>
      <arg name="buffer" type="object" interface="wl_buffer" summary="buffer object for screenmirror"/>
    </request>

    <request name="start"/>
    <request name="stop"/>

    <enum name="content">
      <entry name="normal" value="0"/>
      <entry name="video" value="1"/>
    </enum>

    <enum name="stretch">
      <entry name="keep_ratio" value="0"/>
      <entry name="fully" value="1"/>
    </enum>

    <event name="dequeued">
      <description summary="dequeued event">
        occurs when drawing a captured image on a buffer is finished
      </description>
      <arg name="buffer" type="object" interface="wl_buffer" summary="dequeued buffer which contains a captured image"/>
    </event>

    <event name="content">
      <description summary="content changed event">
        occurs when the content of a captured image is changed. (normal or video)
      </description>
      <arg name="content" type="uint"/>
    </event>

    <event name="stop">
      <description summary="stop event">
        occurs when the screenmirror is stopped eventually
      </description>
    </event>
  </interface>

  <interface name="tizen_video" version="1">

    <description summary="interface for tizen-video">
      Clients can get the video information that the compositor can handle from this interface.
    </description>

    <event name="format">
      <description summary="supported format for video">
        The tbm format codes match the #defines in tbm_surface.h. The formats actually
        supported by the compositor will be reported by the format event.
      </description>
      <arg name="format" type="uint"/>
    </event>

  </interface>

</protocol>
