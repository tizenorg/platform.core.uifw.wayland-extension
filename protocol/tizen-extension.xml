<protocol name="tizen_extension">

  <interface name="tizen_surface" version="1">
    <request name="get_tizen_resource">
      <arg name="id" type="new_id" interface="tizen_resource" />
      <arg name="surface" type="object" interface="wl_surface" />
    </request>
  </interface>

  <interface name="tizen_resource" version="1">
    <request name="destroy" type="destructor" />

    <event name="resource_id">
      <arg name="id" type="uint" />
    </event>
  </interface>

  <interface name="tizen_policy" version="1">
    <request name="get_visibility">
      <arg name="id" type="new_id" interface="tizen_visibility" summary="new visibility object"/>
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>

    <request name="get_position">
      <arg name="id" type="new_id" interface="tizen_position" summary="new position object"/>
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>

    <request name="activate">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>

    <request name="raise">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>

    <request name="lower">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>

    <request name="set_focus_skip">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>

    <request name="unset_focus_skip">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>

    <request name="set_role">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
      <arg name="role" type="string"/>
    </request>

    <!-- for conformant -->
    <request name="set_conformant">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>

    <request name="unset_conformant">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>

    <request name="get_conformant">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
    </request>

    <event name="conformant">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
      <arg name="is_conformant" type="uint"/>
    </event>

    <enum name="conformant_part">
      <entry name="indicator" value="0"/>
      <entry name="keyboard" value="1"/>
      <entry name="clipboard" value="2"/>
    </enum>

    <event name="conformant_area">
      <arg name="surface" type="object" interface="wl_surface" summary="surface object"/>
      <arg name="conformant_part" type="uint"/>
      <arg name="state" type="uint"/>
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
      <arg name="w" type="int"/>
      <arg name="h" type="int"/>
    </event>

    <enum name="error_state">
      <entry name="none" value="0"/>
      <entry name="permission_denied" value="1"/>
    </enum>

    <!-- for notification -->
    <enum name="level">
      <entry name="1" value="0"/>
      <entry name="2" value="1"/>
      <entry name="3" value="2"/>
      <entry name="none" value="-1"/>
      <entry name="default" value="10"/>
      <entry name="medium" value="20"/>
      <entry name="high" value="30"/>
      <entry name="top" value="40"/>
    </enum>

    <request name="set_notification_level">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="level" type="int"/>
    </request>

    <event name="notification_done">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="level" type="int"/>
      <arg name="error_state" type="uint"/>
    </event>

    <!-- for transient_for -->
    <request name="set_transient_for">
      <arg name="child_id" type="uint" />
      <arg name="parent_id" type="uint" />
    </request>

    <request name="unset_transient_for">
      <arg name="child_id" type="uint" />
    </request>

    <event name="transient_for_done">
      <arg name="child_id" type="uint"/>
    </event>

    <!-- for window_screen_mode -->
    <enum name="mode">
      <entry name="default" value="0"/>
      <entry name="always_on" value="1"/>
    </enum>

    <request name="set_window_screen_mode">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="mode" type="uint"/>
    </request>

    <event name="window_screen_mode_done">
      <arg name="surface" type="object" interface="wl_surface"/>
      <arg name="mode" type="uint"/>
      <arg name="error_state" type="uint"/>
    </event>

    <!-- for subsurface -->
    <request name="place_subsurface_below_parent">
      <arg name="subsurface" type="object" interface="wl_subsurface"/>
    </request>
  </interface>

  <interface name="tizen_visibility" version="1">
    <request name="destroy" type="destructor"/>

    <enum name="visibility">
      <entry name="unobscured" value="0"/>
      <entry name="partially_obscured" value="1"/>
      <entry name="fully_obscured" value="2"/>
    </enum>

    <event name="notify">
      <arg name="visibility" type="uint"/>
    </event>
  </interface>

  <interface name="tizen_position" version="1">
    <request name="destroy" type="destructor"/>

    <request name="set">
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
    </request>

    <event name="changed">
      <arg name="x" type="int"/>
      <arg name="y" type="int"/>
    </event>
  </interface>

  <interface name="tizen_keyrouter" version="1">
    <description summary="an interface to set each focus for each key">
      In tradition, all the keys in a keyboard and a device on which
      some keys are attached will be sent to focus surface by default.
      Currently it's possible to set up each focus for each key in a keyboard and a device.
      Therefore, by setting a key grab for a surface, the owner of the
      surface will get the key event when it has the key grab for the key.
    </description>

    <enum name="error">
      <entry name="none" value="0" summary="no error"/>
      <entry name="invalid_surface" value="1" summary="Given surface is invalid."/>
      <entry name="invalid_key" value="2" summary="Given key is invalid."/>
      <entry name="invalid_mode" value="3" summary="Given mode is invalid."/>
      <entry name="grabbed_already" value="4" summary="The key has been grabbed already."/>
      <entry name="no_permission" value="5" summary="The wl client has no permission to grab the key."/>
      <entry name="no_system_resources" value="6" summary="System resources are insufficient."/>
    </enum>

    <enum name="mode">
      <description summary="mode for a key grab">
        This value is used to set a mode for a key grab. With this mode and
        the order of the surface between surfaces' stack, the compositor will determine the destination client
        surface.
      </description>
      <entry name="none" value="0" summary="none"/>
      <entry name="shared" value="1"
       summary="mode to get a key grab with the other client surfaces when the focused client surface gets the key"/>
      <entry name="topmost" value="2"
       summary="mode to get a key grab when the client surface is the top most surface"/>
      <entry name="overridable_exclusive" value="3"
       summary="mode to get a key grab exclusively, overridably regardless of the order in the surface stack"/>
      <entry name="exclusive" value="4"
       summary="mode to get a key grab exclusively regardless of the order in surface stack"/>
    </enum>

    <request name="set_keygrab">
      <arg name="surface" type="object" interface="wl_surface" allow-null="true"/>
      <arg name="key" type="uint"/>
      <arg name="mode" type="uint"/>
    </request>

    <request name="unset_keygrab">
      <arg name="surface" type="object" interface="wl_surface" allow-null="true"/>
      <arg name="key" type="uint"/>
    </request>

    <request name="get_keygrab_status">
      <arg name="surface" type="object" interface="wl_surface" allow-null="true"/>
      <arg name="key" type="uint"/>
    </request>

    <event name="keygrab_notify">
      <arg name="surface" type="object" interface="wl_surface" allow-null="true"/>
      <arg name="key" type="uint"/>
      <arg name="mode" type="uint"/>
      <arg name="error" type="uint"/>
    </event>
  </interface>

  <interface name="tizen_screenshooter" version="1">
    <description summary="interface for tizen-screenshooter">
      Clients can get a screenmirror object from this interface.
    </description>

    <request name="get_screenmirror">
      <description summary="create a screenmirror object">
        Before using screenmirror, a client should get a screenmirror object from display
        server.
      </description>
      <arg name="id" type="new_id" interface="tizen_screenmirror" summary="new screenmirror object"/>
      <arg name="output" type="object" interface="wl_output" summary="output object for screenmirror"/>
    </request>
  </interface>

  <interface name="tizen_screenmirror" version="1">
    <description summary="interface for screenmirror">
      A client can use this interface to get stream images of screen. Before starting,
      queue all buffers. Then, start a screenmirror. After starting, a dequeued event
      will occur when drawing a captured image on a buffer is finished. You might
      need to queue the dequeued buffer again to get a new image from display server.
    </description>

    <request name="destroy" type="destructor"/>

    <request name="set_stretch">
      <arg name="stretch" type="uint" summary="stretch type for screenmirror"/>
    </request>

    <request name="queue">
      <description summary="queue a buffer"/>
        <arg name="buffer" type="object" interface="wl_buffer" summary="buffer object for screenmirror"/>
    </request>

    <request name="dequeue">
      <description summary="dequeue a buffer">
        A user can dequeue a buffer from display server when he wants to take back it from server.
      </description>
      <arg name="buffer" type="object" interface="wl_buffer" summary="buffer object for screenmirror"/>
    </request>

    <request name="start"/>
    <request name="stop"/>

    <enum name="content">
      <entry name="normal" value="0"/>
      <entry name="video" value="1"/>
    </enum>

    <enum name="stretch">
      <entry name="keep_ratio" value="0"/>
      <entry name="fully" value="1"/>
    </enum>

    <event name="dequeued">
      <description summary="dequeued event">
        occurs when drawing a captured image on a buffer is finished
      </description>
      <arg name="buffer" type="object" interface="wl_buffer" summary="dequeued buffer which contains a captured image"/>
    </event>

    <event name="content">
      <description summary="content changed event">
        occurs when the content of a captured image is changed. (normal or video)
      </description>
      <arg name="content" type="uint"/>
    </event>

    <event name="stop">
      <description summary="stop event">
        occurs when the screenmirror is stopped eventually
      </description>
    </event>
  </interface>

  <interface name="tizen_buffer_pool" version="1">
    <request name="authenticate">
      <arg name="id" type="uint"/>
    </request>

    <request name="create_buffer">
      <arg name="id" type="new_id" interface="wl_buffer"/>
      <arg name="name" type="uint"/>
      <arg name="width" type="int"/>
      <arg name="height" type="int"/>
      <arg name="stride" type="uint"/>
      <arg name="format" type="uint"/>
    </request>

    <request name="create_planar_buffer">
      <arg name="id" type="new_id" interface="wl_buffer"/>
      <arg name="width" type="int"/>
      <arg name="height" type="int"/>
      <arg name="format" type="uint"/>
      <arg name="name0" type="uint"/>
      <arg name="offset0" type="int"/>
      <arg name="stride0" type="int"/>
      <arg name="name1" type="uint"/>
      <arg name="offset1" type="int"/>
      <arg name="stride1" type="int"/>
      <arg name="name2" type="uint"/>
      <arg name="offset2" type="int"/>
      <arg name="stride2" type="int"/>
    </request>

    <event name="device">
      <arg name="name" type="string"/>
    </event>

    <event name="authenticated"/>

    <event name="capabilities">
      <arg name="value" type="uint"/>
    </event>

    <event name="format">
      <arg name="format" type="uint"/>
    </event>

    <enum name="error">
      <entry name="invalid_format" value="0"/>
      <entry name="invalid_name" value="1"/>
    </enum>

    <enum name="capability">
      <entry name="default" value="0"/>
      <entry name="video" value="0x1"/>
      <entry name="screenmirror" value="0x2"/>
    </enum>

    <enum name="format">
      <entry name="c8" value="0x20203843"/>
      <entry name="rgb332" value="0x38424752"/>
      <entry name="bgr233" value="0x38524742"/>
      <entry name="xrgb4444" value="0x32315258"/>
      <entry name="xbgr4444" value="0x32314258"/>
      <entry name="rgbx4444" value="0x32315852"/>
      <entry name="bgrx4444" value="0x32315842"/>
      <entry name="argb4444" value="0x32315241"/>
      <entry name="abgr4444" value="0x32314241"/>
      <entry name="rgba4444" value="0x32314152"/>
      <entry name="bgra4444" value="0x32314142"/>
      <entry name="xrgb1555" value="0x35315258"/>
      <entry name="xbgr1555" value="0x35314258"/>
      <entry name="rgbx5551" value="0x35315852"/>
      <entry name="bgrx5551" value="0x35315842"/>
      <entry name="argb1555" value="0x35315241"/>
      <entry name="abgr1555" value="0x35314241"/>
      <entry name="rgba5551" value="0x35314152"/>
      <entry name="bgra5551" value="0x35314142"/>
      <entry name="rgb565" value="0x36314752"/>
      <entry name="bgr565" value="0x36314742"/>
      <entry name="rgb888" value="0x34324752"/>
      <entry name="bgr888" value="0x34324742"/>
      <entry name="xrgb8888" value="0x34325258"/>
      <entry name="xbgr8888" value="0x34324258"/>
      <entry name="rgbx8888" value="0x34325852"/>
      <entry name="bgrx8888" value="0x34325842"/>
      <entry name="argb8888" value="0x34325241"/>
      <entry name="abgr8888" value="0x34324241"/>
      <entry name="rgba8888" value="0x34324152"/>
      <entry name="bgra8888" value="0x34324142"/>
      <entry name="xrgb2101010" value="0x30335258"/>
      <entry name="xbgr2101010" value="0x30334258"/>
      <entry name="rgbx1010102" value="0x30335852"/>
      <entry name="bgrx1010102" value="0x30335842"/>
      <entry name="argb2101010" value="0x30335241"/>
      <entry name="abgr2101010" value="0x30334241"/>
      <entry name="rgba1010102" value="0x30334152"/>
      <entry name="bgra1010102" value="0x30334142"/>
      <entry name="yuyv" value="0x56595559"/>
      <entry name="yvyu" value="0x55595659"/>
      <entry name="uyvy" value="0x59565955"/>
      <entry name="vyuy" value="0x59555956"/>
      <entry name="ayuv" value="0x56555941"/>
      <entry name="nv12" value="0x3231564e"/>
      <entry name="nv21" value="0x3132564e"/>
      <entry name="nv16" value="0x3631564e"/>
      <entry name="nv61" value="0x3136564e"/>
      <entry name="yuv410" value="0x39565559"/>
      <entry name="yvu410" value="0x39555659"/>
      <entry name="yuv411" value="0x31315559"/>
      <entry name="yvu411" value="0x31315659"/>
      <entry name="yuv420" value="0x32315559"/>
      <entry name="yvu420" value="0x32315659"/>
      <entry name="yuv422" value="0x36315559"/>
      <entry name="yvu422" value="0x36315659"/>
      <entry name="yuv444" value="0x34325559"/>
      <entry name="yvu444" value="0x34325659"/>

      <!-- specail formats for samsung exynos -->
      <entry name="st12" value="0x32315453"/>
      <entry name="sn12" value="0x32314e53"/>
    </enum>
  </interface>

</protocol>
